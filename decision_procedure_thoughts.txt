derive function should return o-case last, because they then gather on the left side
it allows to define a predicate over all derivative plus lists of sequence, in the form of c0//s_;_c1::l where Forall (fun c => Success_;_ c1//s \/ Failure_;_c1//s)
One must then show that a list always beginning in c0//s.... followed by elements satisfying the predicate P, is contained in the configuration ...
This isn't true in the strict sense of containment, but it holds morally if we rather than list equality use =L=, where l0 =L= l1 when plus_fold l0 =R= plus_fold l1
In_L l0 l_conf can then be reduced by taking the head of both lists and proving this case separately (must give a lemma that shows this decomposition)
What remains is a potentially empty tail of l0, and a l_conf' only consisting of a uniform configuration. 
If l0' and l_conf' have the same length, the proposition must hold because all elements of l0 can be mapped to a list in l_conf'.
If l0' is too short, it can be failure extended, after which we use the same argument as before.
The challenging case is if it is too long. In that case we must show that since all elements in l0' are equivalent to an element in the finite list Failure::l0_AllDerivatives, (because all contracts satisfying the predicates must correspond to an element in that list), then there must exists two equivalent elements in l0', more specifically l0' can be decomposed into l++[x]++l'++[x1]++l'' where x =R= x1. 
By idempotance on plust_lists this must be equivalent (=L=) to l++[x]++l', shoretning the list by 1. In some way this lemma should be generalized, so that it can be applied n times, where n is the size difference between l0' and l_conf', yielding a list of length l0', in which case we do as before.
